#!/usr/bin/env node

/**
 * PostgreSQL to MySQL Schema Converter
 * 
 * This script handles more advanced schema conversion from PostgreSQL to MySQL.
 * It uses the output from pg_dump to generate MySQL compatible schema.
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');

// Configuration
const inputFile = process.argv[2] || './migration/schema.sql';
const outputFile = process.argv[3] || './migration/mysql_schema_enhanced.sql';

if (!fs.existsSync(inputFile)) {
  console.error(`Input file not found: ${inputFile}`);
  console.error('Usage: node pg-to-mysql-converter.js [input_file] [output_file]');
  process.exit(1);
}

// Create output directory if it doesn't exist
const outputDir = path.dirname(outputFile);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

const writeStream = fs.createWriteStream(outputFile);
const logStream = fs.createWriteStream(`${outputDir}/conversion_log.txt`);

// MySQL header
writeStream.write('-- MySQL Schema converted from PostgreSQL\n');
writeStream.write('-- Generated by Zenith Migration Tool\n\n');
writeStream.write('SET FOREIGN_KEY_CHECKS = 0;\n\n');

// State tracking
let inTable = false;
let currentTableName = '';
let currentTableDefinition = [];
let currentIndices = [];
let tableNames = [];
let columnDefinitions = {};
let foreignKeys = [];
let sequenceNames = {};
let sequenceTables = {};

// Type mapping
const typeMap = {
  'boolean': 'BOOLEAN',
  'uuid': 'CHAR(36)',
  'character varying': 'VARCHAR',
  'character varying\\((\\d+)\\)': 'VARCHAR($1)',
  'jsonb': 'JSON',
  'json': 'JSON',
  'timestamp with time zone': 'DATETIME',
  'timestamp without time zone': 'DATETIME',
  'date': 'DATE',
  'time': 'TIME',
  'text': 'TEXT',
  'integer': 'INT',
  'smallint': 'SMALLINT',
  'bigint': 'BIGINT',
  'numeric': 'DECIMAL(10,2)',
  'numeric\\((\\d+),(\\d+)\\)': 'DECIMAL($1,$2)',
  'double precision': 'DOUBLE',
  'real': 'FLOAT',
  'bytea': 'BLOB',
  'tsvector': 'TEXT'
};

// Function replacement map
const functionMap = {
  'public\\.uuid_generate_v4\\(\\)': 'UUID()',
  'gen_random_uuid\\(\\)': 'UUID()',
  'now\\(\\)': 'CURRENT_TIMESTAMP()',
  'CURRENT_TIMESTAMP': 'CURRENT_TIMESTAMP()',
  'nextval\\(\'([^\']+)\'::regclass\\)': 'NULL' // Handle later with AUTO_INCREMENT
};

// Process the schema file line by line
const rl = readline.createInterface({
  input: fs.createReadStream(inputFile),
  crlfDelay: Infinity
});

// Process the input file
rl.on('line', (line) => {
  // Skip PostgreSQL specific commands
  if (line.match(/^SET|^--/)) {
    return;
  }
  
  // Skip extensions
  if (line.match(/^CREATE EXTENSION|^COMMENT ON EXTENSION/)) {
    logStream.write(`Skipping PostgreSQL extension: ${line}\n`);
    return;
  }
  
  // Skip functions and triggers
  if (line.match(/^CREATE (FUNCTION|TRIGGER)/)) {
    logStream.write(`Skipping PostgreSQL function/trigger: ${line}\n`);
    let skipUntil = line.match(/\$\$/) ? '$$;' : 'END;';
    rl.on('line', function skipFunction(line) {
      if (line.includes(skipUntil)) {
        rl.removeListener('line', skipFunction);
      }
    });
    return;
  }
  
  // Extract sequence information
  const seqMatch = line.match(/^CREATE SEQUENCE public\.(.*)/);
  if (seqMatch) {
    const seqName = seqMatch[1].split(' ')[0];
    sequenceNames[seqName] = true;
    logStream.write(`Found sequence: ${seqName}\n`);
    return;
  }
  
  // Handle CREATE TABLE statements
  const tableMatch = line.match(/^CREATE TABLE public\.(.*) \(/);
  if (tableMatch) {
    inTable = true;
    currentTableName = tableMatch[1];
    tableNames.push(currentTableName);
    currentTableDefinition = [`CREATE TABLE \`${currentTableName}\` (`];
    columnDefinitions[currentTableName] = {};
    logStream.write(`Processing table: ${currentTableName}\n`);
    return;
  }
  
  // Process table definition
  if (inTable) {
    // Check for end of table definition
    if (line.match(/^\);$/)) {
      inTable = false;
      
      // Add auto-increment to primary key if table used a sequence
      let tableDefinition = currentTableDefinition.join('\n');
      for (const seqName in sequenceTables) {
        if (sequenceTables[seqName] === currentTableName) {
          const seqColumn = seqName.replace(`${currentTableName}_`, '').replace('_seq', '');
          tableDefinition = tableDefinition.replace(
            new RegExp(`\`${seqColumn}\`\\s+INT\\s+NOT\\s+NULL`, 'i'),
            `\`${seqColumn}\` INT NOT NULL AUTO_INCREMENT`
          );
        }
      }
      
      // Add MySQL table options
      tableDefinition += '\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n';
      writeStream.write(tableDefinition);
      
      // Write indices for this table if any
      if (currentIndices.length > 0) {
        writeStream.write(`-- Indices for table ${currentTableName}\n`);
        currentIndices.forEach(index => {
          writeStream.write(`${index}\n`);
        });
        writeStream.write('\n');
        currentIndices = [];
      }
      
      return;
    }
    
    // Process column definition
    const columnMatch = line.match(/^\s+([^\s]+)\s+(.*?),?$/);
    if (columnMatch) {
      let [_, columnName, definition] = columnMatch;
      columnName = columnName.trim();
      
      // Store column definition for later reference
      columnDefinitions[currentTableName][columnName] = definition;
      
      // Convert data types
      for (const pgType in typeMap) {
        const mysqlType = typeMap[pgType];
        const typeRegex = new RegExp(pgType, 'g');
        definition = definition.replace(typeRegex, mysqlType);
      }
      
      // Convert functions
      for (const pgFunc in functionMap) {
        const mysqlFunc = functionMap[pgFunc];
        const funcRegex = new RegExp(pgFunc, 'g');
        definition = definition.replace(funcRegex, mysqlFunc);
      }
      
      // Handle sequences in default values
      const seqMatch = definition.match(/DEFAULT nextval\('public\.([^']+)'::regclass\)/);
      if (seqMatch) {
        const seqName = seqMatch[1];
        sequenceTables[seqName] = currentTableName;
        // Replace with NULL for now, we'll add AUTO_INCREMENT later
        definition = definition.replace(/DEFAULT nextval\([^)]+\)/, '');
        logStream.write(`Found column using sequence: ${currentTableName}.${columnName} -> ${seqName}\n`);
      }
      
      // Backtick the column name
      currentTableDefinition.push(`  \`${columnName}\` ${definition}`);
      return;
    }
    
    // Capture constraint definitions (primary keys, unique constraints, etc.)
    const constraintMatch = line.match(/^\s+CONSTRAINT\s+([^\s]+)\s+(.*?),?$/);
    if (constraintMatch) {
      let [_, constraintName, definition] = constraintMatch;
      
      // Handle primary keys
      if (definition.startsWith('PRIMARY KEY')) {
        definition = definition.replace(/\(([^)]+)\)/, (match, columns) => {
          const backtickColumns = columns.split(',')
            .map(col => `\`${col.trim()}\``)
            .join(',');
          return `(${backtickColumns})`;
        });
      }
      
      // Handle foreign keys
      if (definition.startsWith('FOREIGN KEY')) {
        const fkMatch = definition.match(/FOREIGN KEY \(([^)]+)\) REFERENCES public\.([^\(]+)\(([^)]+)\)/);
        if (fkMatch) {
          const [_, columns, refTable, refColumns] = fkMatch;
          const backtickColumns = columns.split(',')
            .map(col => `\`${col.trim()}\``)
            .join(',');
          const backtickRefColumns = refColumns.split(',')
            .map(col => `\`${col.trim()}\``)
            .join(',');
          
          definition = `FOREIGN KEY (${backtickColumns}) REFERENCES \`${refTable}\`(${backtickRefColumns})`;
          
          // Collect foreign keys for later creation (after all tables)
          foreignKeys.push({
            table: currentTableName,
            constraint: constraintName,
            definition: definition
          });
          
          // Skip adding this to table definition, we'll add all foreign keys at the end
          return;
        }
      }
      
      // Handle CHECK constraints - MySQL doesn't have CHECK constraints prior to 8.0.16
      if (definition.startsWith('CHECK')) {
        logStream.write(`Skipping CHECK constraint on ${currentTableName}: ${definition}\n`);
        return;
      }
      
      currentTableDefinition.push(`  CONSTRAINT \`${constraintName}\` ${definition}`);
      return;
    }
    
    // Include any other lines in the table definition
    if (line.trim() !== '') {
      currentTableDefinition.push(`  ${line}`);
    }
  }
  
  // Handle CREATE INDEX statements
  const indexMatch = line.match(/^CREATE (UNIQUE )?INDEX ([^\s]+) ON public\.([^\s]+) (.+);$/);
  if (indexMatch) {
    const [_, isUnique, indexName, tableName, definition] = indexMatch;
    const uniqueStr = isUnique ? 'UNIQUE ' : '';
    
    // Convert the index definition to MySQL syntax
    let mysqlDefinition = definition
      .replace(/USING [^\s]+/, '') // Remove USING clause
      .replace(/\(([^)]+)\)/, (match, columns) => {
        return `(${columns})`; // Keep columns as is for now
      });
    
    const mysqlIndex = `CREATE ${uniqueStr}INDEX \`${indexName}\` ON \`${tableName}\` ${mysqlDefinition};`;
    
    if (tableName === currentTableName) {
      currentIndices.push(mysqlIndex);
    } else {
      writeStream.write(`${mysqlIndex}\n`);
    }
    
    return;
  }
  
  // Handle ALTER TABLE statements for adding foreign keys
  const alterMatch = line.match(/^ALTER TABLE ONLY public\.([^\s]+)\s+ADD CONSTRAINT ([^\s]+) (.+);$/);
  if (alterMatch) {
    const [_, tableName, constraintName, definition] = alterMatch;
    
    // Handle foreign keys
    if (definition.startsWith('FOREIGN KEY')) {
      const fkMatch = definition.match(/FOREIGN KEY \(([^)]+)\) REFERENCES public\.([^\(]+)\(([^)]+)\)/);
      if (fkMatch) {
        const [_, columns, refTable, refColumns] = fkMatch;
        const backtickColumns = columns.split(',')
          .map(col => `\`${col.trim()}\``)
          .join(',');
        const backtickRefColumns = refColumns.split(',')
          .map(col => `\`${col.trim()}\``)
          .join(',');
        
        const mysqlDefinition = `FOREIGN KEY (${backtickColumns}) REFERENCES \`${refTable}\`(${backtickRefColumns})`;
        
        foreignKeys.push({
          table: tableName,
          constraint: constraintName,
          definition: mysqlDefinition
        });
      }
    }
    
    return;
  }
});

rl.on('close', () => {
  // Add all foreign keys at the end to avoid reference problems
  if (foreignKeys.length > 0) {
    writeStream.write('-- Foreign key constraints\n');
    foreignKeys.forEach(fk => {
      writeStream.write(`ALTER TABLE \`${fk.table}\` ADD CONSTRAINT \`${fk.constraint}\` ${fk.definition};\n`);
    });
    writeStream.write('\n');
  }
  
  // Enable foreign key checks again
  writeStream.write('SET FOREIGN_KEY_CHECKS = 1;\n');
  
  writeStream.end();
  logStream.end();
  
  console.log(`
Migration schema conversion completed:
- Input file: ${inputFile}
- Output MySQL schema: ${outputFile}
- Conversion log: ${outputDir}/conversion_log.txt
- Processed ${tableNames.length} tables
- Created ${foreignKeys.length} foreign key constraints

Next steps:
1. Review the generated MySQL schema file
2. Check the conversion log for any issues
3. Apply the schema to your MySQL database
4. Use the migration script to transfer the data
`);
});
