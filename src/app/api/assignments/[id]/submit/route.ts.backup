import { NextRequest, NextResponse } from "next/server";
import db from "@/lib/database";
import { verifyAuth } from "@/lib/auth-unified";

// Helper function to handle errors consistently
function handleApiError(error: any) {
  console.error("Error submitting assignment:", error);
  
  // More detailed error logging
  if (error.code) {
    console.error(`Database error code: ${error.code}`);
  }
  if (error.stack) {
    console.error(`Error stack: ${error.stack}`);
  }
  
  return NextResponse.json(
    { 
      error: error.message || "Internal server error", 
      details: error.code || "Unknown error",
      timestamp: new Date().toISOString()
    },
    { status: 500 }
  );
}

// POST /api/assignments/[id]/submit - Submit an assignment
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const { id: assignmentId } = resolvedParams;
    
    // Verify authentication using centralized AuthMiddleware
    const authResult = await verifyAuth(request);
    if (!authResult.success) {
      return NextResponse.json(
        { error: authResult.error || "Unauthorized" }, 
        { status: 401 }
      );
    }

    const userId = authResult.user!.id;

    // Get request body
    const body = await request.json();
    const { 
      answers,
      startedAt, 
      completedAt, 
      timeSpent,
      violationCount, 
      autoSubmitted,
      violations = [],
      proctoringData = {},
      browserInfo = {}
    } = body;

    if (!answers || !Array.isArray(answers)) {
      return NextResponse.json(
        { error: "Invalid submission data" },
        { status: 400 }
      );
    }

    // Check if assignment exists and is still open
    const assignmentCheck = await db.$executeRaw(
      `SELECT id, due_date, status FROM assignments WHERE id = $1`,
      [assignmentId]
    );

    if (assignmentCheck.rows.length === 0) {
      return NextResponse.json(
        { error: "Assignment not found" },
        { status: 404 }
      );
    }

    const assignment = assignmentCheck.rows[0];
    const now = new Date();
    const dueDate = new Date(assignment.due_date);

    // Check if assignment is past due (unless it's being auto-submitted)
    if (dueDate < now && !autoSubmitted) {
      return NextResponse.json(
        { error: "Assignment is past due" },
        { status: 400 }
      );
    }

    // Check if already submitted
    const existingSubmission = await db.$executeRaw(
      `SELECT id FROM assignment_submissions WHERE assignment_id = $1 AND user_id = $2`,
      [assignmentId, userId]
    );

    if (existingSubmission.rows.length > 0) {
      return NextResponse.json(
        { error: "You have already submitted this assignment" },
        { status: 400 }
      );
    }

    // Get client IP and user agent
    const clientIP = request.headers.get('x-forwarded-for') || 
                     request.headers.get('x-real-ip') || 
                     'unknown';
    const userAgent = request.headers.get('user-agent') || 'unknown';

    // Create submission record
    const submissionResult = await db.$executeRaw(
      `INSERT INTO assignment_submissions (
        assignment_id, user_id, started_at, completed_at,
        time_spent, violation_count, auto_submitted, status,
        ip_address, user_agent
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, 'submitted', $8, $9)
      RETURNING id`,
      [
        assignmentId,
        userId,
        startedAt ? new Date(startedAt) : now,
        completedAt ? new Date(completedAt) : now,
        timeSpent || 0,
        violationCount || 0,
        autoSubmitted || false,
        clientIP,
        userAgent
      ]
    );

    const submissionId = submissionResult.rows[0].id;

    // Record proctoring session if proctoring data is provided
    if (assignment.is_proctored && Object.keys(proctoringData).length > 0) {
      await db.$executeRaw(
        `INSERT INTO proctoring_sessions (
          assignment_id, user_id, session_start, session_end,
          camera_enabled, microphone_enabled, face_verified,
          violations, system_info, session_data
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
        [
          assignmentId,
          userId,
          startedAt ? new Date(startedAt) : now,
          completedAt ? new Date(completedAt) : now,
          proctoringData.cameraEnabled || false,
          proctoringData.microphoneEnabled || false,
          proctoringData.faceVerified || false,
          JSON.stringify(violations),
          JSON.stringify(browserInfo),
          JSON.stringify(proctoringData)
        ]
      );
    }

    // Record individual violations
    if (violations && violations.length > 0) {
      for (const violation of violations) {
        await db.$executeRaw(
          `INSERT INTO assignment_violations (
            submission_id, violation_type, occurred_at, details
          )
          VALUES ($1, $2, $3, $4)`,
          [
            submissionId,
            violation.type || 'unknown',
            violation.timestamp ? new Date(violation.timestamp) : now,
            JSON.stringify(violation.details || {})
          ]
        );
      }
    }

    // Get all questions for this assignment
    const questionsResult = await db.$executeRaw(
      `SELECT id, question_type, marks FROM assignment_questions WHERE assignment_id = $1`,
      [assignmentId]
    );

    const questions = questionsResult.rows;
    let totalScore = 0;

    // Process each answer
    for (const answer of answers) {
      let { questionId, selectedOptions, codeAnswer, essayAnswer, timeSpent: questionTimeSpent } = answer;
      
      // Validate questionId is a valid UUID
      if (!questionId || typeof questionId !== 'string') {
        console.warn('Invalid questionId:', questionId);
        continue;
      }
      
      // Find the question in our fetched questions
      const question = questions.find(q => q.id === questionId);
      if (!question) {
        console.warn('Question not found:', questionId);
        continue;
      }
      
      let isCorrect: boolean | null = false;
      let score = 0;

      // For objective questions, check if the answer is correct
      if (question.question_type === 'single_choice' || question.question_type === 'multiple_choice') {
        // Get correct options
        const optionsResult = await db.$executeRaw(
          `SELECT id FROM question_options WHERE question_id = $1 AND is_correct = true`,
          [questionId]
        );
        
        const correctOptions = optionsResult.rows.map(row => row.id);
        
        // Validate and filter selectedOptions to ensure they are valid UUIDs
        const validSelectedOptions = (selectedOptions || []).filter((option: any) => {
          if (!option || typeof option !== 'string') return false;
          // Basic UUID format check
          const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
          return uuidRegex.test(option);
        });
        
        // For single choice, there should be exactly one correct answer
        if (question.question_type === 'single_choice') {
          isCorrect = validSelectedOptions.length === 1 && 
                      correctOptions.includes(validSelectedOptions[0]);
        } 
        // For multiple choice, selected options should match correct options exactly
        else {
          // Sort both arrays for comparison
          const sortedSelected = [...validSelectedOptions].sort();
          const sortedCorrect = [...correctOptions].sort();
          
          isCorrect = sortedSelected.length === sortedCorrect.length &&
                      sortedSelected.every((value, index) => value === sortedCorrect[index]);
        }
        
        // Award full marks if correct
        score = isCorrect ? question.marks : 0;
        
        // Use validated selectedOptions for database insertion
        selectedOptions = validSelectedOptions;
      }
      // For coding and essay questions, store the answers but don't auto-grade
      else {
        // These will be graded manually, set isCorrect to null
        isCorrect = null;
        score = 0; // Initialize with 0, will be updated by instructor later
      }

      // Record this response
      const responseResult = await db.$executeRaw(
        `INSERT INTO question_responses (
          submission_id, question_id, selected_options,
          code_answer, essay_answer, is_correct, score, time_spent
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id`,
        [
          submissionId,
          questionId,
          selectedOptions || [],
          codeAnswer || null,
          essayAnswer || null,
          isCorrect,
          score,
          questionTimeSpent || 0
        ]
      );

      // Add to total score if graded automatically
      if (score !== null) {
        totalScore += score;
      }
    }

    // Update submission with total score for auto-graded questions
    await db.$executeRaw(
      `UPDATE assignment_submissions SET total_score = $1 WHERE id = $2`,
      [totalScore, submissionId]
    );

    // Get the assignment's max points for reference
    const maxPointsResult = await db.$executeRaw(
      `SELECT COALESCE(SUM(marks), 0) as max_points FROM assignment_questions WHERE assignment_id = $1`,
      [assignmentId]
    );
    
    const maxPoints = maxPointsResult.rows[0]?.max_points || 0;

    return NextResponse.json({
      submissionId,
      message: "Assignment submitted successfully",
      totalScore,
      maxPoints,
      percentage: maxPoints > 0 ? ((totalScore / maxPoints) * 100) : 0,
      autoGraded: true,
      success: true
    });
  } catch (error: any) {
    return handleApiError(error);
  }
}
