import { NextRequest, NextResponse } from "next/server";
import { db } from '@/lib/database';
import { verifyAuth, withAuth } from "@/lib/auth-unified";

// Define interface for attempt row
interface AttemptRow {
  id: string;
  attempt_number: number;
  start_time: string;
  end_time: string | null;
  score: number | null;
  status: string;
  answers: string | object;
  violations: string | object;
  submitted_at: string | null;
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: assignmentId } = await params;
    
    // Verify authentication using centralized AuthMiddleware
    const authResult = await verifyAuth(request);
    if (!authResult.success) {
      return NextResponse.json(
        { error: authResult.error || "Unauthorized" }, 
        { status: 401 }
      );
    }

    const userId = authResult.user!.id;

    // Get user details
    const user = await db.users.findUnique({
      where: { id: userId },
      select: { id: true, email: true, name: true }
    });
    
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Get user's attempts for this assignment
    const attempts = await db.assignment_attempts.findMany({
      where: { 
        assignment_id: assignmentId, 
        user_id: user.id 
      },
      orderBy: { attempt_number: 'desc' },
      select: {
        id: true,
        attempt_number: true,
        start_time: true,
        end_time: true,
        score: true,
        status: true,
        answers: true,
        violations: true,
        submitted_at: true
      }
    });

    return NextResponse.json({ attempts });

  } catch (error) {
    console.error('Error fetching attempts:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(
  request: NextRequest
) {
  try {
    const authHeader = request.headers.get('authorization');
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const { attemptId, answers, violation } = await request.json();
    
    // Extract and verify the token
    const token = authHeader.replace('Bearer ', '');
    const decoded = verifyAuth(token);
    
    if (!decoded || !decoded.userId) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 });
    }
    
    // Get user details using the verified userId
    const user = await db.users.findUnique({
      where: { id: decoded.userId },
      select: { id: true, email: true, name: true }
    });
    
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Update attempt with new answers or violations
    if (violation) {
      // Get current attempt
      const attempt = await db.assignment_attempts.findFirst({
        where: { 
          id: attemptId, 
          user_id: user.id 
        },
        select: { violations: true }
      });
      
      if (!attempt) {
        return NextResponse.json({ error: 'Attempt not found' }, { status: 404 });
      }

      // Safe JSON parsing with fallback
      const parseJsonSafely = (value: unknown, fallback: unknown) => {
        if (!value) return fallback;
        if (typeof value === 'object') return value;
        if (typeof value === 'string') {
          try {
            return JSON.parse(value);
          } catch (error) {
            console.warn('Failed to parse JSON:', value, error);
            return fallback;
          }
        }
        return fallback;
      };

      const currentViolations = parseJsonSafely(attempt.violations, []);
      const updatedViolations = [...currentViolations, {
        type: violation.type,
        message: violation.message,
        timestamp: new Date().toISOString()
      }];

      await db.assignment_attempts.update({
        where: { 
          id: attemptId,
          user_id: user.id 
        },
        data: { 
          violations: updatedViolations as any,
          updated_at: new Date()
        }
      });

      return NextResponse.json({ success: true, violations: updatedViolations });
    } else if (answers) {
      // Save progress
      await db.assignment_attempts.update({
        where: { 
          id: attemptId,
          user_id: user.id 
        },
        data: { 
          answers: answers as any,
          updated_at: new Date()
        }
      });

      return NextResponse.json({ success: true });
    }

    return NextResponse.json({ error: 'Invalid request' }, { status: 400 });

  } catch (error) {
    console.error('Error updating attempt:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
