'use client';

import React, { useState, useEffect, useRef } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Save, ArrowLeft, Plus, Trash2, Edit3, Eye, Settings, Clock, Users,
  Shield, Camera, Mic, Monitor, Calculator, BookOpen, FileText, Code,
  RotateCw, Shuffle, Target, Award, AlertTriangle, CheckCircle, Brain,
  Upload, Download, Copy, RefreshCw, Zap, Globe, Lock, Unlock, PlayCircle
} from 'lucide-react';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/contexts/ToastContext';
import { PaperpalHeader } from '@/components/PaperpalHeader';

interface Question {
  id?: string;
  question_type: 'single_choice' | 'multiple_choice' | 'multi_select' | 'coding' | 'essay' | 'true_false' | 'integer';
  title: string;
  description: string;
  options?: string[];
  correct_answer: any;
  points: number;
  ordering: number;
  time_limit?: number;
  code_language?: string;
  starter_code?: string;
  test_cases?: any[];
  expected_output?: string;
  explanation?: string;
  integer_min?: number;
  integer_max?: number;
  integer_step?: number;
  allowed_languages?: string[];
  allow_any_language?: boolean;
}

interface AssignmentData {
  title: string;
  description: string;
  assignment_type: 'regular' | 'objective' | 'coding' | 'essay';
  target_audience: 'club' | 'all_clubs' | 'specific_clubs';
  target_clubs?: string[];
  max_points: number;
  time_limit: number;
  passing_score: number;
  is_proctored: boolean;
  shuffle_questions: boolean;
  allow_calculator: boolean;
  show_results: boolean;
  allow_review: boolean;
  shuffle_options: boolean;
  max_attempts: number;
  require_fullscreen: boolean;
  auto_submit_on_violation: boolean;
  max_violations: number;
  require_camera: boolean;
  require_microphone: boolean;
  require_face_verification: boolean;
  allow_navigation: boolean;
  coding_instructions: string;
  objective_instructions: string;
  mixed_instructions: string;
  essay_instructions: string;
  code_editor_settings: {
    theme: string;
    autoSave: boolean;
    fontSize: number;
    wordWrap: boolean;
    autoSaveInterval: number;
  };
  proctoring_settings: any;
  due_date: string;
  start_date: string;
  questions: Question[];
}

export default function AssignmentEditorPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { user } = useAuth();
  const { showToast } = useToast();

  const [assignment, setAssignment] = useState<AssignmentData | null>(null);
  const [activeTab, setActiveTab] = useState<'basic' | 'questions' | 'settings' | 'proctoring' | 'preview'>('basic');
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [editingQuestion, setEditingQuestion] = useState<number | null>(null);
  const [sidebarOpen, setSidebarOpen] = useState(false);

  const [showQuestionTypeMenu, setShowQuestionTypeMenu] = useState(false);
  const questionMenuRef = useRef<HTMLDivElement>(null);

  // Check authentication status
  useEffect(() => {
    const checkAuth = async () => {
      // Skip auth check if we have assignment data (coming from ZEN Assistant)
      const hasAssignmentData = searchParams.get('key') || searchParams.get('zenData');
      
      if (!user && !hasAssignmentData) {
        showToast({
          title: 'Authentication Required',
          message: 'Please sign in to access the assignment editor.',
          type: 'error'
        });
        router.push('/login');
        return;
      }
      
      // If we have assignment data but no user, try to validate session silently
      if (!user && hasAssignmentData) {
        try {
          const response = await fetch('/api/auth/validate');
          if (!response.ok) {
            console.info('Session validation failed, but continuing with assignment data from ZEN Assistant');
            // Continue silently since we have assignment data from ZEN Assistant
          }
        } catch (error) {
          console.info('Auth check failed, but continuing with assignment data from ZEN Assistant:', error);
          // Continue silently since we have assignment data from ZEN Assistant
        }
      }
    };
    
    checkAuth();
  }, [user, router, showToast, searchParams]);

  useEffect(() => {
    // Prevent running if we already have assignment data
    if (assignment) {
      console.log('Assignment already loaded, skipping data loading');
      return;
    }
    
    // Check for a pending assignment after login
    const pendingKey = searchParams.get('pendingKey');
    if (pendingKey) {
      console.log('Found pending assignment key after login:', pendingKey);
      try {
        const pendingData = localStorage.getItem(pendingKey);
        if (pendingData) {
          const pendingAssignment = JSON.parse(pendingData);
          setAssignment(pendingAssignment);
          setLoading(false);
          showToast({
            title: 'Assignment Restored',
            message: 'Your work has been restored after login.',
            type: 'success'
          });
          console.log('Successfully restored pending assignment after login');
          return;
        }
      } catch (error) {
        console.error('Error restoring pending assignment:', error);
      }
    }

    let assignmentData: any = null;
    let dataSource = '';
    
    // First try to get data from sessionStorage (primary method)
    const storageKey = searchParams.get('key');
    if (storageKey) {
      console.log('Looking for assignment data with key:', storageKey);
      
      // Create an array of storage strategies to try in sequence
      const storageStrategies = [
        // Strategy 1: Session Storage (primary)
        {
          name: 'sessionStorage',
          fetch: () => {
            const data = sessionStorage.getItem(storageKey);
            if (data) return { data, needsParsing: true };
            return null;
          }
        },
        // Strategy 2: Local Storage direct
        {
          name: 'localStorage',
          fetch: () => {
            const data = localStorage.getItem(storageKey);
            if (data) return { data, needsParsing: true };
            return null;
          }
        },
        // Strategy 3: Local Storage backup with TTL
        {
          name: 'localStorage_backup',
          fetch: () => {
            const backupKey = `backup_${storageKey}`;
            const data = localStorage.getItem(backupKey);
            if (!data) return null;
            
            const parsed = JSON.parse(data);
            if (parsed.expires && parsed.expires > Date.now()) {
              return { data: parsed.data, needsParsing: true };
            }
            return null;
          }
        },
        // Strategy 4: Window object temporary storage
        {
          name: 'windowObject',
          fetch: () => {
            if (typeof window !== 'undefined' && (window as any).__ZENITH_TEMP_ASSIGNMENT) {
              const data = (window as any).__ZENITH_TEMP_ASSIGNMENT;
              // Clean up as we retrieve it
              delete (window as any).__ZENITH_TEMP_ASSIGNMENT;
              return { data, needsParsing: true };
            }
            return null;
          }
        }
      ];
      
      // Try each strategy until we get data
      for (const strategy of storageStrategies) {
        try {
          console.log(`Trying to load data using strategy: ${strategy.name}`);
          const result = strategy.fetch();
          
          if (result) {
            const { data, needsParsing } = result;
            const parsedData = needsParsing ? JSON.parse(data) : data;
            
            if (parsedData && parsedData.title) {
              assignmentData = parsedData;
              dataSource = strategy.name;
              console.log(`Assignment data loaded successfully from ${strategy.name}:`, parsedData.title);
              break;
            }
          }
        } catch (error) {
          console.error(`Error with storage strategy ${strategy.name}:`, error);
        }
      }
      
      // Log the final outcome
      if (assignmentData) {
        console.log(`Assignment successfully loaded from ${dataSource}`);
      } else {
        console.warn('All storage strategies failed to retrieve assignment data');
      }
    } else {
      console.log('No storage key provided in URL');
    }
    
    // Fallback to URL parameter method (old method)
    if (!assignmentData) {
      const zenData = searchParams.get('zenData');
      if (zenData) {
        console.log('Falling back to URL parameter method');
        try {
          assignmentData = JSON.parse(decodeURIComponent(zenData));
          console.info('Assignment data loaded from URL parameters');
          dataSource = 'urlParameter';
        } catch (error) {
          console.error('Error parsing URL assignment data:', error);
        }
      }
    }
    
    if (assignmentData) {
      console.log('Setting assignment data:', assignmentData.title, 'from source:', dataSource);
      setAssignment(assignmentData);
      setLoading(false);
      
      // Clean up storage after successfully setting the assignment
      if (storageKey) {
        // Run a comprehensive cleanup to ensure no lingering data
        cleanupPendingAssignment();
        
        showToast({
          title: 'Assignment Loaded',
          message: 'Your AI-generated assignment has been loaded successfully.',
          type: 'success'
        });
      }
    } else {
      console.error('No assignment data found anywhere');
      setLoading(false);
      showToast({
        title: 'No Assignment Data',
        message: 'No assignment data found. Redirecting to assignments page.',
        type: 'error'
      });
      // Add a small delay before redirecting to ensure the toast is shown
      setTimeout(() => {
        router.push('/assignments');
      }, 2000);
    }
  }, [assignment, searchParams, router, showToast]);

  // Close question type menu when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (questionMenuRef.current && !questionMenuRef.current.contains(event.target as Node)) {
        setShowQuestionTypeMenu(false);
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);
  
  // Cleanup effect when component unmounts
  useEffect(() => {
    return () => {
      // Clean up any assignment data when navigating away or unmounting
      cleanupPendingAssignment();
    };
  }, []);
  
  // Function to clean up all assignment-related storage
  const cleanupPendingAssignment = () => {
    try {
      console.log('Running thorough storage cleanup...');
      
      // Check if there's a pending key in the URL
      const pendingKey = searchParams.get('pendingKey');
      if (pendingKey) {
        localStorage.removeItem(pendingKey);
        console.log('Cleaned up pending assignment data from pendingKey:', pendingKey);
      }
      
      // Clean up storage key if present
      const storageKey = searchParams.get('key');
      if (storageKey) {
        // Remove from all possible storage locations
        try {
          sessionStorage.removeItem(storageKey);
          localStorage.removeItem(`backup_${storageKey}`);
          // Clean up any other related keys that might be lingering
          localStorage.removeItem(storageKey);
          console.log('Cleaned up all storage for key:', storageKey);
        } catch (e) {
          console.warn('Error during storage key cleanup:', e);
        }
      }
      
      // Also clean up all pending save flags
      localStorage.removeItem('zenith_pending_save');
      
      // Clean up temp window object storage
      if (typeof window !== 'undefined' && (window as any).__ZENITH_TEMP_ASSIGNMENT) {
        delete (window as any).__ZENITH_TEMP_ASSIGNMENT;
        console.log('Cleaned up window object temporary storage');
      }
      
      // Search for and clean up any other zenith_assignment_ keys that might be lingering
      if (typeof window !== 'undefined') {
        // Check session storage
        for (let i = 0; i < sessionStorage.length; i++) {
          const key = sessionStorage.key(i);
          if (key && key.startsWith('zenith_assignment_')) {
            sessionStorage.removeItem(key);
            console.log('Cleaned up extra session storage key:', key);
          }
        }
        
        // Check local storage
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && (key.startsWith('zenith_assignment_') || key.startsWith('backup_zenith_assignment_'))) {
            localStorage.removeItem(key);
            console.log('Cleaned up extra local storage key:', key);
          }
        }
      }
    } catch (error) {
      console.error('Error during comprehensive storage cleanup:', error);
    }
  };

  const handleSaveAssignment = async () => {
    if (!assignment) return;
    
    // If no user, preserve the assignment and redirect to login
    if (!user) {
      try {
        // Generate a unique key for this pending assignment
        const pendingKey = `zenith_pending_assignment_${Date.now()}`;
        
        // Store the current assignment state in localStorage for persistence
        localStorage.setItem(pendingKey, JSON.stringify(assignment));
        
        // Also store a flag indicating we have a pending assignment after login
        localStorage.setItem('zenith_pending_save', pendingKey);
        
        console.log('Assignment preserved for after login with key:', pendingKey);
        
        showToast({
          title: 'Login Required',
          message: 'Your work is saved. Please log in to continue.',
          type: 'info'
        });
        
        // Redirect to login with a return URL parameter
        router.push(`/login?returnTo=${encodeURIComponent(`/assignments/editor?pendingKey=${pendingKey}`)}`);
        return;
      } catch (error) {
        console.error('Failed to preserve assignment before login:', error);
        showToast({
          title: 'Login Required',
          message: 'Please log in to save your assignment.',
          type: 'warning'
        });
        router.push('/login');
        return;
      }
    }

    setSaving(true);
    try {
      // Prepare assignment data for API (matching the expected format)
      const assignmentPayload = {
        title: assignment.title,
        description: assignment.description,
        clubId: user.club_id,
        startDate: assignment.start_date,
        dueDate: assignment.due_date,
        maxPoints: assignment.questions.reduce((sum: number, q: Question) => sum + q.points, 0),
        instructions: assignment.description,
        assignmentType: assignment.assignment_type,
        targetAudience: assignment.target_audience,
        targetClubs: assignment.target_clubs || [],
        timeLimit: assignment.time_limit,
        allowNavigation: assignment.allow_navigation,
        passingScore: assignment.passing_score,
        isProctored: assignment.is_proctored,
        requireCamera: assignment.require_camera,
        questions: assignment.questions.map(q => ({
          questionType: q.question_type,
          title: q.title,
          description: q.description,
          options: q.options || [],
          correctAnswer: q.correct_answer,
          points: q.points,
          explanation: q.explanation || '',
        }))
      };

      const response = await fetch('/api/assignments', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(assignmentPayload),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to save assignment');
      }

      const savedAssignment = await response.json();
      
      // Run comprehensive cleanup of all assignment-related storage
      cleanupPendingAssignment();
      
      console.log('Assignment saved successfully with ID:', savedAssignment.id);
      
      showToast({
        title: 'Assignment Saved',
        message: 'Assignment has been saved successfully',
        type: 'success'
      });
      
      router.push('/assignments');
    } catch (error) {
      console.error('Save error:', error);
      showToast({
        title: 'Save Failed',
        message: error instanceof Error ? error.message : 'Failed to save assignment. Please try again.',
        type: 'error'
      });
    } finally {
      setSaving(false);
      
      // Even if saving fails, we should try to clean up any temporary data
      // to avoid potential conflicts on future attempts
      try {
        cleanupPendingAssignment();
      } catch (e) {
        console.warn('Error during cleanup after save attempt:', e);
      }
    }
  };

  // Rest of the component code goes here...
  // This includes UI rendering, question editing functions, etc.

  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen w-full">
        <div className="animate-pulse flex flex-col items-center">
          <div className="h-16 w-16 rounded-full bg-blue-200 flex items-center justify-center">
            <RotateCw className="h-8 w-8 text-blue-500 animate-spin" />
          </div>
          <h2 className="mt-4 text-lg font-semibold text-gray-700 dark:text-gray-300">
            Loading Assignment...
          </h2>
        </div>
      </div>
    );
  }

  // Render the UI
  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <header className="bg-white dark:bg-gray-800 shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
          <div className="flex items-center">
            <button 
              onClick={() => router.push('/assignments')}
              className="mr-4 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700"
            >
              <ArrowLeft className="h-5 w-5 text-gray-600 dark:text-gray-300" />
            </button>
            <div>
              <h1 className="text-xl font-semibold text-gray-800 dark:text-white">Assignment Editor</h1>
              <p className="text-sm text-gray-500 dark:text-gray-400">Configure your AI-generated assignment</p>
            </div>
          </div>
          
          <div className="flex items-center space-x-2">
            <button
              onClick={() => setActiveTab('preview')}
              className={`px-3 py-1.5 rounded ${
                activeTab === 'preview' 
                  ? 'bg-blue-50 text-blue-600 dark:bg-blue-900 dark:text-blue-300' 
                  : 'text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700'
              }`}
            >
              <div className="flex items-center">
                <Eye className="h-4 w-4 mr-1" />
                <span>Preview</span>
              </div>
            </button>
            
            <button
              onClick={handleSaveAssignment}
              disabled={saving}
              className="px-4 py-1.5 bg-blue-600 hover:bg-blue-700 text-white rounded flex items-center disabled:opacity-50"
            >
              {saving ? (
                <>
                  <RotateCw className="h-4 w-4 mr-2 animate-spin" />
                  <span>Saving...</span>
                </>
              ) : (
                <>
                  <Save className="h-4 w-4 mr-2" />
                  <span>Save Assignment</span>
                </>
              )}
            </button>
          </div>
        </div>
      </header>

      {/* Main content would be here - tabs, editors, etc. */}
      
    </div>
  );
}
